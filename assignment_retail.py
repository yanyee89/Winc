# -*- coding: utf-8 -*-
"""assignment-retail.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a51tPbxj3NoJfdjBcl0_B2kgvG8cDU09

<img src="https://static.wincacademy.nl/logos/main-logo.png" height=200px style="height: 200px"/>

# Assignment: Retail

Congratulations! You've reached the final assignment for the course before the bonus modules. Here we'll ask you to work with a dataset from the Dutch *Centraal Bureau voor de Statistiek* (CBS, English: Statistics Netherlands). It contains monthly growth percentages for various branches of the retail sector. You'll be required to answer open questions as well as write code that handles the data and crunches numbers.

*Answer open questions as though you were writing a report. Answers that are too vague, too short or too sloppy will be rejected.*

## 0. Load required modules

First, we need to load some modules that we're going to use. Do that in the next code cell. If you don't know yet which modules you'll use, just read on and come back here to import them later. **Don't forget to run the cell whenever you make an edit!**
"""

# Your import statements here.
from google.colab import files
uploaded = files.upload()

"""## 1. Data Preparation
Now we need to load and parse the data. The data should be located in the same folder as this notebook (whether that's on Google Colab or your local machine). Make sure you have working file path from your notebook to the supplied `data.csv` file. Put an `x` in the checkbox below when you're ready.

- [X] *I have a working file path to the `data.csv` file.*

You are now ready to proceed with reading the data into your program.

### 1.1 Read the CSV

The data comes in the form of a `csv`-file. CSV stands for 'comma separated values'. Oddly enough it need not be the case that the values are *really* separated by commas. In this case, the **delimiter** - the character that separates the columns within a datapoint - is *not* a comma. It's up to you to inspect `data.csv` and find out what the delimiter is.

Once you know what the delimiter is, you can use Python's `csv` module to read each of the datapoints to a dictionary. Some tips:

- The module's name is `csv`.
- You can find its documentation [here](https://docs.python.org/3/library/csv.html)
- We suggest you use the `DictReader` class. There's an example on how to use `DictReader` in the linked documentation.
- Instead of printing the rows (like in the example), we suggest you store all the rows as `dict`s in a `list`.

**1. In the code cell below, write code that opens and reads the data. By the end of the cell, you should have a variable `data` that is a list of dictionaries that each contain a datapoint.**
"""

# Your code here.
import csv
with open('retail-data.csv', newline='') as csvfile:
  reader = csv.DictReader(csvfile)
  print(reader)

"""### 1.2 Parse and clean the data

You now have a list of dictionaries that each contain some data. But what data? Answer the following questions to become familiar with this dataset. It requires you to write and execute Python code (you can add code cells if you wish), and also search the web for terms you're not familiar with.

**2. What are the column names in this dataset, and what do they mean? Be specific.**

*TODO: Your answer here.*
Bedrijfstakken/branches (SBI 2008) = this column contains the information in which field the company is active in (for example, drugstore, DIY, foodstuffs). There are different branches in this list. Bear in mind that this is only for the year 2008.

Perioden = this columns shows which year and month it is describing.  

Omzet ongecorrigeerd/Indexcijfers/Waarde (2015=100) = The information here is giving an index the revenue in value sales of that month for that branche against 2005. For example if the revenue is lower 2008 against 2005 (base year), then the index will fall below 100. If it's the other way around - then the index will be higher than 100. This is an easy way to see if you're performing better or worse against 2005. 

The data is not corrected, meaning that there will be season's effect etc. will be in there, which can cause the data be more fluctuated. 

Omzet ongecorrigeerd/Indexcijfers/Volume (2015=100) = he information here is giving an index the revenue in volume sales of that month for that branche against 2005. For example if the revenue is lower 2008 against 2005 (base year), then the index will fall below 100. If it's the other way around - then the index will be higher than 100. This is an easy way to see if you're performing better or worse against 2005.  

The data is not corrected, meaning that there will be season's effect etc. will be in there, which can cause the data be more fluctuated. 











**3. For each column, list what data type it should have (`str`, `int`, `float` or `datetime.date`).**

*TODO: Your answer here.*
Bedrijfstakken/branches (SBI 2008) = str

Perioden = datetime.date

Omzet ongecorrigeerd/Indexcijfers/Waarde (2015=100) =  float

Omzet ongecorrigeerd/Indexcijfers/Volume (2015=100) = float
    
**4. In the code cell below, write code that changes the column names to something more convenient for writing readable code. Be sure to choose English, correct and meaningful names.**
"""

import csv


with open('retail-data.csv', 'r') as infile:    
    contents = infile.readlines() 
    new_line = []
    for line in contents:
        for head in str(line).split(';'):                 
            if head == '"Bedrijfstakken/branches (SBI 2008)"':                
                new_line.insert(0,'Branches 2008')
                continue
            elif head == '"Perioden"':
                new_line.insert(1,'Periods')
                continue
            elif head == '"Omzet ongecorrigeerd/Indexcijfers/Waarde (2015=100)"':
                new_line.insert(2,'index value sales vs 2015')
                continue            
            new_line.insert(3,'index volume sales vs 2015')
        break 
  
    contents.insert(0, '; '.join(new_line))

"""**5. In the code cell below, write code that casts all the data to the right type.**

Tips:
- If you overwite your data, running the casting operation you're about to implement more than once might result in errors. In that case you can opt not to reuse a variable or restart and rerun your notebook for every retry.
- The data is in Dutch. For some columns this does not matter, but for one in particular it makes parsing it a little bit harder. There is a way to handle this in a few lines of code. You'll need Python's `locale` module for this, as well as the special string `'nl_NL.UTF-8'`. If you're not sure how to use this information after searching the web for a while, it's OK to take the long way around and write custom code to handle the Dutch words.
- The parsing script is bound to run into errors. **Do not modify the data file on disk.** Carefully read the error, examine why it works on most values and crashes on some others, and apply a fix in your code! We'll give you some tips:
    - A handful of values in the `Perioden`-column might cause an error due to an unexpected character. You can safely ignore that character.
    - Handle missing numerical values by replacing them with `-1.`. Be sure to maintain the correct datatype for that column!
"""

import csv
from os import remove
import time 
import locale
from datetime import datetime

# Your code here.
def translate_period(period_string):
    mapping = {
        "januari": "january",
        "februari": "february",
        "maart": "march",
        "mei": "may",
        "juni": "june",
        "juli": "july",
        "augustus": "august",
        "oktober": "october"
    }
    for k, v in mapping.items():
        period_string = period_string.replace(k, v)
    return period_string 


# new object for working on
new_data_object = []

with open('retail-data.csv', 'r') as infile:    
    contents = infile.readlines()        
    for index,line in enumerate(contents):
        new_built_line = []
        # not interested in headers            
        if index == 0:                              
            continue
        for subindex,item in enumerate(str(line).split(';')):
            # not interested in the first data column as its already strings
            if subindex == 0:
                new_built_line.insert(subindex, item)
                continue
            # check and parse dates
            if subindex == 1:                    
                if item is not None:
                    parsed_date = 0
                    #item = item.rstrip()
                    removal = item.replace('*','')
                    clean_date = removal.strip('"').strip()                           
                    if item.find('*') != -1:                           
                        try:                         
                            parsed_date = datetime.strptime(translate_period(clean_date), '%Y %B')
                        except:
                            print('error converting line: ' + str(index) + ' ' + str(item))                            
                    else:
                        try:                         
                            parsed_date = datetime.strptime(translate_period(clean_date), '%Y %B')
                        except:
                            print('error converting line: ' + str(index) + ' ' + str(item))
                    new_built_line.insert(subindex, parsed_date)
            if subindex == 2:                                  
                if item is not None and item.isspace() is False:
                    try:
                        new_float = float(item.replace('"', ''))
                        new_built_line.insert(subindex, new_float)
                    except:
                        print('Could not convert string to number' + item)
                        new_built_line.insert(subindex, -1)
                else:
                    new_built_line.insert(subindex, -1)
            if subindex == 3:                    
                if item is not None and item.isspace() is False:
                    try:                        
                        new_float = float(item.replace('"', ''))
                        new_built_line.insert(subindex, new_float)
                    except:
                        print('Could not convert string to number' + item)
                        new_built_line.insert(subindex, -1)
                else:
                    new_built_line.insert(subindex, -1) 
        new_data_object.insert(index, new_built_line)

"""## 2. Data Exploration

You are now ready to explore the data.

**6. In the code cell below, print the following metadata. Format the printed text in a nice and tidy way. Put an `x` in the checkboxes when you've succeeded.**

- [X] **The number of datapoints in the dataset.**
- [X] **The number of unique branches of the retail sector the data covers.**
- [X] **The first month covered by the data.**
- [X] **The last month covered by the data.**
"""

import collections
import csv
from os import remove
import time 
import locale
from datetime import datetime
from collections import Counter
# Your code here.
def metadata():
    with open('retail-data.csv', 'r') as infile:    
        contents = infile.readlines()
        row_counter = 0
        point_counter = 0
        name_list = []
        first_month = ''
        last_month = ''
        for index,line in enumerate(contents):
            if index ==0:
                continue
            row_counter+=1
            for subindex,point in enumerate(str(line).split(';')):
                point_counter+=1
                if subindex == 0:
                    clean_string = point.replace('"', '')
                    name_list.append(clean_string)
                if index == 1 and subindex == 1:
                    removal = point.replace('*','')
                    clean_date = removal.strip('"').strip()
                    first_month = translate_period(clean_date)
                    
               
        for j,x in enumerate(str(contents[row_counter]).split(';')):
            if j == 1:
                removal = x.replace('*','')
                clean_date = removal.strip('"').strip()
                last_month = clean_date

        print('number of data rows: ' + str(row_counter))
        print('number of points within row: ' + str(point_counter))
        print('number of unique branches: ' + str(len(Counter(name_list).keys())))
        print('first month of data set: ' + first_month)
        print('last month of data set: ' + last_month)

metadata()

"""**7. In the code cell below, extract the revenue numbers for the following two sectors and put them in a list named exactly as indicated. Also create a list that contains all the months in ascending order. Run the cell after it to see a plot of the numbers if you did it correctly.**

- [ ] Months in ascending order $\Longrightarrow$ `months`
- [ ] Clothing stores $\Longrightarrow$  `clothing_stores_revenue`
    - Tip: the Dutch word for *'clothing'* is *'kleding'*
- [ ] Mail order companies and web shops $\Longrightarrow$ `mail_order_revenue`
    - Tip: the Dutch term for *'mail order companies'* is *'postorderbedrijven'*
"""

import collections
import csv
from os import remove
import time 
import locale
from datetime import datetime
from collections import Counter

months = []
clothing_stores_revenue = []
mail_order_revenue = []


with open('retail-data.csv', 'r') as infile:    
    contents = infile.readlines()        
    for index,line in enumerate(contents):            
        # not interested in headers            
        if index == 0:                              
            continue
        list_for_indexing = list(str(line).split(';'))
        for subindex,item in enumerate(str(line).split(';')):
            # not interested in the first data column as its already strings
            if subindex == 0:
                continue                    
            # check and parse dates
            if subindex == 1:                    
                continue
            if subindex == 2:
                check_string = list_for_indexing[0]
                month_string = list_for_indexing[1]                    
                if 'kleding' in check_string.replace('"', ''):                        
                    if item is not None and item.isspace() is False:
                        try:
                            new_float = float(item.replace('"', ''))
                            clothing_stores_revenue.append(new_float)                               
                            months.append(month_string.replace('"', '').replace('*',''))
                        except:
                            print('Could not convert string to number' + item)
                            clothing_stores_revenue.insert(0)
                    else:
                        clothing_stores_revenue.insert(0)
                    continue
                if 'Postorderbedrijven' in check_string.replace('"', ''):                        
                    if item is not None and item.isspace() is False:
                        try:
                            new_float = float(item.replace('"', ''))
                            mail_order_revenue.append(new_float)                                
                        except:
                            print('Could not convert string to number' + item)
                            mail_order_revenue.insert(0)
                    else:
                        mail_order_revenue.insert(0)
                    continue
            if subindex == 3:                    
                continue

# Commented out IPython magic to ensure Python compatibility.
# Do not modify the code in this cell.
import matplotlib.pyplot as plt
# %matplotlib inline

try:
    fig, ax = plt.subplots(figsize=(16, 9))
    ax.plot(months, clothing_stores_revenue, label="Clothing stores' revenue")
    ax.plot(months, mail_order_revenue, label="Mail order companies' revenue")
    ax.set_xlabel('Date')
    ax.set_ylabel('Percent, 2015=100')
    ax.legend()
    plt.show()
except Exception as e:
    print('There was an error creating the plot.\n'
          'Check if your lists are correctly named and assembled.\n'
          "Here's your error, for your debugging pleasure.")
    raise e

"""**8. How do the two branches compare? Discuss any yearly cycles you observe, as well as long-term developments. Also explain why you think these patterns are there. Pretend you are writing this to your supervisor or a client who asked you to analyze this dataset.**

The graph is showing the revenue over time across 2 branches (clothing store and mail order companies). The blue line is representing the revenue of the clothing store and the orange line is representing mail orders companies' revenue. 

What can be seen is that the clothing stores' revenue has dropped over the years. At the same time, the mail orders companies' revenue has trended upwards and overtaking clothing stores. 

There is dips seen in the revenue of clothing stores in Jan/Feb and July/Aug. A possiblble explanation for this is that consumers' have spend their money in December (Sinterklaas, Kerst, Nieuwjaar), and therefore cut back on their spending in these two months. Regarding to July/Aug is that they can be on holiday abroad and therefore have no opportunity to spend it in the clothing stores. 

The reason why the clothing stores revenue has declined starting March 2020 is due to COVID. The government requested that people do not go out unnecessarily and this has reflected back in the revenue.

The mail order is growing year on year, this is partially that consumers are more used to ordering it via the mail order and liking the convenience of it. Mail order is having a similar pattern as the clothing shops, with a sales dip in Jan/Feb and July/Aug, although the dip is not as big if you compare to clothing stores. Once COVID started in the Netherlands (March 2020) you see that the sales significantly increased and took over the clothing stores. This is due to that consumers were discouraged to go out and they ordered more online. 

I believe that the long term development is that consumers will return back to the clothing stores and increase the revenue there.However, the revenue will most likely not return to the level pre-COVID, as consumers have discovered the convenience of mail order companies (and getting it delivered at your home) the online shopping is here to stay and will continue to grow.

## 3. Computing With Data

### 3.1 Year Over Year Change

Let's take a closer look at these two branches of retail: clothing stores and mail order companies. A commonly used metric in business is the year-over-year revenue change. It is computed like so:

$$\text{YoY}_\text{month} = \frac{\text{Revenue}_\text{month}}{\text{Revenue}_\text{same month last year}} \times 100$$

Search the web for a longer explanation of this term if you'd like one.

**9. Why should we compare revenue for a particular month to the revenue of that same month, one year ago?**


This is to understand if you're performing better or worse versus a year ago and how muich better/worse you are performing. If you are looking into a specific month, there might be that there was a promotion there which cause increased sales and you have a benchmark if that works or not. Other factors like COVID can have an impact on the performance of the clothing or mail order companies. 

**10. In the code cell below, compute the year-over-year revenue change for every month, for both branches of the retail sector, each in their own new list. Skip the first year (why?). Put an `x` in the checkboxes when you're ready. Run the next cell to see a new plot for your data.**

- [x] Clothing stores $\Longrightarrow$ `clothing_stores_yoy`
- [x] Mail order companies $\Longrightarrow$ `mail_order_yoy`
"""

# Skipping the first year as there is no revenue data in the year before and therefore the calculation is invalid. 

# Your code here.
import collections
import csv
from os import remove
import time 
import locale
from datetime import datetime
from collections import Counter


clothing_stores_yoy = []
mail_order_yoy = []
  
master_list_clothes = list(zip(months[12:], clothing_stores_revenue[12:]))    

jan_num = 0
feb_num = 0
mar_num = 0
apr_num = 0
may_num = 0
june_num = 0
july_num =0
aug_num = 0
sep_num =0
oct_num =0
nov_num= 0
dec_num = 0
month_counter = 1
is_first = True

for x, j in master_list_clothes:
    if month_counter == 1:            
        if not is_first:
            clothing_stores_yoy.append((j/jan_num)*100)
        jan_num = j
        month_counter+=1
        continue
    if month_counter == 2:            
        if not is_first:
            clothing_stores_yoy.append((j/feb_num)*100)
        feb_num = j
        month_counter+=1
        continue
    if month_counter == 3:            
        if not is_first:
            clothing_stores_yoy.append((j/mar_num)*100)
        mar_num = j
        month_counter+=1
        continue
    if month_counter == 4:            
        if not is_first:
            clothing_stores_yoy.append((j/apr_num)*100)
        apr_num = j
        month_counter+=1
        continue
    if month_counter == 5:            
        if not is_first:
            clothing_stores_yoy.append((j/may_num)*100)
        may_num = j
        month_counter+=1
        continue
    if month_counter == 6:            
        if not is_first:
            clothing_stores_yoy.append((j/june_num)*100)
        june_num = j
        month_counter+=1
        continue
    if month_counter == 7:            
        if not is_first:
            clothing_stores_yoy.append((j/july_num)*100)
        july_num = j
        month_counter+=1
        continue
    if month_counter == 8:            
        if not is_first:
            clothing_stores_yoy.append((j/aug_num)*100)
        aug_num = j
        month_counter+=1
        continue
    if month_counter == 9:            
        if not is_first:
            clothing_stores_yoy.append((j/sep_num)*100)
        sep_num = j
        month_counter+=1
        continue
    if month_counter == 10:            
        if not is_first:
            clothing_stores_yoy.append((j/oct_num)*100)
        oct_num = j
        month_counter+=1
        continue
    if month_counter == 11:            
        if not is_first:
            clothing_stores_yoy.append((j/nov_num)*100)
        nov_num = j
        month_counter+=1
        continue
    if month_counter == 12:            
        if not is_first:
            clothing_stores_yoy.append((j/dec_num)*100)
        dec_num = j        
        is_first = False
        continue
# reset variables and months array and call 
   
master_list_mail_order = list(zip(months[12:], mail_order_revenue[12:]))

jan_num = 0
feb_num = 0
mar_num = 0
apr_num = 0
may_num = 0
june_num = 0
july_num =0
aug_num = 0
sep_num =0
oct_num =0
nov_num= 0
dec_num = 0
is_first = True
month_counter=1


for x, j in master_list_mail_order:   
    if month_counter == 1:                 
        if not is_first:            
            mail_order_yoy.append((j/jan_num)*100)
        jan_num = j
        month_counter+=1        
        continue
    if month_counter == 2:            
        if not is_first:
            mail_order_yoy.append((j/feb_num)*100)
        feb_num = j
        month_counter+=1
        continue
    if month_counter == 3:            
        if not is_first:
            mail_order_yoy.append((j/mar_num)*100)
        mar_num = j
        month_counter+=1
        continue
    if month_counter == 4:            
        if not is_first:
            mail_order_yoy.append((j/apr_num)*100)
        apr_num = j
        month_counter+=1
        continue
    if month_counter == 5:            
        if not is_first:
            mail_order_yoy.append((j/may_num)*100)
        may_num = j
        month_counter+=1
        continue
    if month_counter == 6:            
        if not is_first:
            mail_order_yoy.append((j/june_num)*100)
        june_num = j
        month_counter+=1
        continue
    if month_counter == 7:            
        if not is_first:
            mail_order_yoy.append((j/july_num)*100)
        july_num = j
        month_counter+=1
        continue
    if month_counter == 8:            
        if not is_first:
            mail_order_yoy.append((j/aug_num)*100)
        aug_num = j
        month_counter+=1
        continue
    if month_counter == 9:            
        if not is_first:
            mail_order_yoy.append((j/sep_num)*100)
        sep_num = j
        month_counter+=1
        continue
    if month_counter == 10:            
        if not is_first:
            mail_order_yoy.append((j/oct_num)*100)
        oct_num = j
        month_counter+=1
        continue
    if month_counter == 11:            
        if not is_first:
            mail_order_yoy.append((j/nov_num)*100)
        nov_num = j
        month_counter+=1
        continue
    if month_counter == 12:            
        if not is_first:
            mail_order_yoy.append((j/dec_num)*100)
        dec_num = j       
        is_first = False
        continue

# this is to match the number of calculated points in the data sets
months = months[:len(months)-12]

try:  
    fig, ax = plt.subplots(figsize=(16, 9))
    ax.plot(months[12:], clothing_stores_yoy, label="Clothing stores' YoY")
    ax.plot(months[12:], mail_order_yoy, label="Mail order companies' YoY")
    ax.set_xlabel('Date')
    ax.set_ylabel('YoY change, 2015=100')
    ax.legend()
    plt.show()
except Exception as e:
    print('There was an error creating the plot.\n'
          'Check if your lists are correctly named and assembled.\n'
          "Here's your error, for your debugging pleasure.")
    raise e

"""**11. In the code cell below, find the best and worst months for both branches of the retail sector in terms of year-over-year revenue change. Print the branch, month and YoY in a nice and tidy way.**"""

largest_yoy = max(clothing_stores_yoy)
index_of_largest = clothing_stores_yoy.index(largest_yoy)
month_of_largest = months[index_of_largest]

lowest_yoy = min(clothing_stores_yoy)
index_of_lowest = clothing_stores_yoy.index(lowest_yoy)
month_of_lowest = months[index_of_lowest]

print('largest year on year: '+str(largest_yoy), '\ncalculated on: '+ month_of_largest, '\nbranch: clothing store')
print('\nlowest year on year: '+str(lowest_yoy), '\ncalculated on: '+ month_of_lowest, '\nbranch: clothing store')


# online retail
largest_yoy_online = max(mail_order_yoy)
index_of_largest_online = mail_order_yoy.index(largest_yoy_online)
month_of_largest_online = months[index_of_largest_online]

lowest_yoy_online = min(mail_order_yoy)
index_of_lowest_online = mail_order_yoy.index(lowest_yoy_online)
month_of_lowest_online = months[index_of_lowest_online]

print('\nlargest year on year: '+str(largest_yoy_online), '\ncalculated on: '+ month_of_largest_online, '\nbranch: online retail')
print('\nlowest year on year: '+str(lowest_yoy_online), '\ncalculated on: '+ month_of_lowest_online, '\nbranch: online retail')

"""### 3.2 Similarity Between Branches

We've seen that the pattern for revenue is quite different for clothing stores and mail order companies. In other words: their revenues don't move up or down together. A way to make this observation more specific is to compute the **correlation coefficient**. It is a number between $-1$ and $1$ that describes the relation between two *random variables*. Here is how it works applied to our revenue numbers:

- If the correlation coefficient for the revenue of two branches of the retail sector is $1$, their revenue is *positively correlated*. This means that when the revenue of branch A goes up, the revenue of branch B also goes up. In other words: the revenues for both branches go up together.
- If the correlation coefficient is $-1$, the revenues of the two branches are *negatively correlated*. This means that if A's revenue goes up, B's revenue goes down. Similarly, if B's revenue goes up, A's revenue goes down. They move in the exact opposite direction.
- If the correlation coefficient is $0$, there is no clear pattern between the revenues of both branches.

Here's a table that summarizes this information:

| Correlation coefficient | Meaning                              |
|-------------------------|--------------------------------------|
| $1$                     | Revenues go up together              |
| $0$                     | No pattern                           |
| $-1$                    | Revenues move in opposite directions |

Note that there is a continuous scale between $-1$ and $1$! A correlation coefficient of $0.3$ indicates a somewhat positively correlated relationship.

And here's an image that visualizes the correlation coefficient.

<img src="https://upload.wikimedia.org/wikipedia/commons/d/d4/Correlation_examples2.svg"/>

We've provided a function `corrcoef` that computes the correlation coefficient for two lists.

**11. In the code cell below, use the function `corrcoef` to compute the correlation coefficient for each pair of branches in our dataset. Then print a sorted table that shows each unique pair and their correlation coefficients. You can take inspiration from this table (but it doesn't have to look exactly like it):**

```
Coeff   Branch A                                          Branch B                                          
===========================================================================================================
0.98    4711, 472 Winkels in voedingsmiddelen             4711 Supermarkten                                 
0.91    475 Winkels in overige huishoudwaren              4752 Winkels in doe-het-zelfartikelen             
0.91    47528 Bouwmarkten                                 4752 Winkels in doe-het-zelfartikelen               
```
"""

import numpy as np

# Provided function. Use this to obtain the correlation coefficient for two lists.
def corrcoef(branch_a, branch_b):
    return np.corrcoef(branch_a, branch_b)[0, 1]
# Your code here.
branch_name = ''
first_iteration = True
value_list = []
branch_data = []

for row in new_data_object: 
  if first_iteration:
    # dont need to compare branch names on the first loop   
    value_list.append(row[2])
    #print(value_list)
    first_iteration = False
    branch_name = row[0]
    continue  
  if branch_name == row[0]:    
    value_list.append(row[2])
    branch_name = row[0]
    continue
  if branch_name != row[0]:
    branch_data.append(tuple((branch_name, value_list)))
    value_list = []
    value_list.append(row[2])
    branch_name = row[0]
    continue 

corr_list = []
for item in branch_data:
  for sub_item in branch_data:
    if item[0] == sub_item[0]:
      continue
    corr_list.append(tuple((corrcoef(item[1], sub_item[1]),item[0] + ';' + sub_item[0])))

# sort list
sorted_list = sorted(corr_list, key=lambda tup: tup[0],reverse=True)
print('Coeff                              Branch A                                          Branch B                                          ')
print('===========================================================================================================')
for x in sorted_list:
  # seperate two branch names
  split_words = x[1].split(';')  
  print(str(x[0]).ljust(30) + split_words[0].ljust(50) + split_words[1].ljust(40))

"""**12. Pick two correlation coefficients from the table you created and explain why you think these values are the way that they are. Be sure to pick two coefficients that are not close to each other.**
 
Choosing the correlation between 'speelgoedwinkels' and 'supermarkten' where the correlation is -0.427208947361872            .          . 

As the correlation is in the negative, this means that the revenue of those two branches are somewhat moving into the oppositve directions. As toy stores are not selling products that are in the supermarkets, the revenue can not follow the same pattern as the supermarket's revenue. 

Another point is that due to COVID, the toy stores had to close down and therefore missing revenue, while the supermarkets' revenue soared due to consumers starting to stockpile. 

**13. Imagine you are a very risk-averse investor shaping your portfolio of investments in the retail sector. How would you use the information in the table you created to minimize your investment risk? Which two branches of the retail sector would you invest in if you had to pick two? Use the correlation coefficient in your answer.**

*TODO: Your answer here.*

The correlation coefficient is showing if the revenue's of the branches are moving into the same direction or not.

In this case I would pick 2 branches that have a negative correlation. Reason why is that I want to minimize my risk by spreading my investments across different branches so they do not follow the same patter and the needs of the consumers are different. 

I would invest in consumer electrics and supermarkets. Consumers always need to buy foodstuff from the supemarkets and currently with the need for convenience electronics can come into play.

## 4. Conclusion

You made it! This was the Retail assignment. Before you hand it in: restart the kernel and run all the cells. Then save it to GitHub and share the link with us in the usual way.
"""